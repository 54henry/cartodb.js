var Base = require('./base');
var CartoDBLayer = require('../../../geo/map/cartodb-layer');

/**
 * Represent a layer Object.
 * 
 * @param {object} source - The source where the layer will fetch the data.
 * @param {carto.style.CartoCSS} style - A CartoCSS object with the layer styling.
 * @param {object} [options]
 * @param {Array<string>} [options.featureClickColumns=[]] - Columns that will be available for `featureClick` events. 
 * @param {Array<string>} [options.featureOverColumns=[]] - Columns that will be available for `featureOver` events.
 *
 * @fires carto.layer.Layer.FeatureEvent
 * @example
 *
 * // no options
 * new carto.layer.Layer(citiesSource, citiesStyle);
 *
 * @example
 *
 * // with options
 * new carto.layer.Layer(citiesSource, citiesStyle, {
 *   featureClickColumns: [ 'name', 'population' ],
 *   featureOverColumns: [ 'name' ]
 * });
 * 
 * @constructor
 * @memberof carto.layer
 * @api
 */
function Layer (source, style, options) {
  options = options || {};

  this._engine = undefined;
  this._internalModel = undefined;

  this._id = options.id || Layer.$generateId();
  this._source = source;
  this._style = style;
  this._visible = true;
  this._featureClickColumns = options.featureClickColumns || [];
  this._featureOverColumns = options.featureOverColumns || [];
}

Layer.prototype = Object.create(Base.prototype);

/**
 * Return a unique autogenerated id.
 * 
 * @return {string} Unique autogenerated id
 */
Layer.prototype.getId = function () {
  return this._id;
};

/**
 * Set a new style for this layer.
 * 
 * @param {carto.style.CartoCSS} New style
 * @return {Promise} A `Promise` that will be resolved when the new style has been applied.
 * 
 * @api
 */
Layer.prototype.setStyle = function (style, opts) {
  opts = opts || {};
  this._style = style;
  this._internalModel.set('cartocss', style.toCartoCSS(), { silent: true });
  return this._reloadEngine();
};

/**
 * Get the current style for this layer.
 * 
 * @return {carto.style.CartoCSS} Current style.
 *
 * @api
 */
Layer.prototype.getStyle = function () {
  return this._style;
};

/**
 * Set a new source for this layer.
 * 
 * @param {carto.source.Dataset|carto.source.SQL} source New source
 * @return {Promise} A `Promise` that will be resolved when the new source has been set.
 *
 * @api
 */
Layer.prototype.setSource = function (source) {
  this._source = source;
  if (this._internalModel) {
    this._internalModel.set('source', source, { silent: true });
  }
  return this._reloadEngine();
};

/**
 * Get the current source for this layer
 * 
 * @return {carto.source.Dataset|carto.source.SQL} Current source.
 *
 * @api
 */
Layer.prototype.getSource = function () {
  return this._source;
};

/**
 * Set new columns for `featureClick` events
 * 
 * @param {Array<string>} columns An array containing column names.
 * @return {Promise} A `Promise` that will be resolved when the layer is visible.
 *
 * @api
 */
Layer.prototype.setFeatureClickColumns = function (columns) {
  this._featureClickColumns = columns;
  if (this._internalModel) {
    this._internalModel.infowindow.update(getInteractivityFields(columns), { silent: true });
  }

  return this._reloadEngine();
};

/**
 * Return the columns available in `featureClicked` events.
 * 
 * @return  {[Array<string>]} Column names available in `featureClicked` events
 *
 * @api
 */
Layer.prototype.getFeatureClickColumns = function (columns) {
  return this._featureClickColumns;
};

/**
 * Set new columns for `featureOver` events
 * 
 * @param {Array<string>} columns An array containing column names.
 * @return {Promise} A `Promise` that will be resolved when the layer is visible.
 *
 * @api
 */
Layer.prototype.setFeatureOverColumns = function (columns) {
  this._featureOverColumns = columns;
  if (this._internalModel) {
    this._internalModel.tooltip.update(getInteractivityFields(columns), { silent: true });
  }

  return this._reloadEngine();
};

/**
 * Return the columns available in `featureOver` events.
 * 
 * @return  {[Array<string>]} Column names available in `featureOver` events
 *
 * @api
 */
Layer.prototype.getFeatureOverColumns = function (columns) {
  return this._featureOverColumns;
};

/**
 * Hides the layer.
 * @return {Promise} A `Promise` that will be resolved when the layer is hidden.
 *
 * @api
 */
Layer.prototype.hide = function () {
  this._visible = false;
  if (this._internalModel) {
    this._internalModel.set('visible', false, { silent: true });
  }

  return this._reloadEngine();
};

/**
 * Shows the layer.
 * @return {Promise} A `Promise` that will be resolved when the layer is visible.
 *
 * @api
 */
Layer.prototype.show = function () {
  this._visible = true;
  if (this._internalModel) {
    this._internalModel.set('visible', true, { silent: true });
  }

  return this._reloadEngine();
};

Layer.prototype.$setEngine = function (engine) {
  if (this._engine) {
    return;
  }
  this._engine = engine;
  this._source.$setEngine(engine);
  if (!this._internalModel) {
    this._internalModel = this._createInternalModel(engine);
  }
};

Layer.prototype._createInternalModel = function (engine) {
  return new CartoDBLayer({
    id: this._id,
    source: this._source.$getInternalModel(),
    cartocss: this._style.toCartoCSS(),
    visible: this._visible,
    infowindow: getInteractivityFields(this._featureClickColumns),
    tooltip: getInteractivityFields(this._featureOverColumns)
  }, { engine: engine });
};

Layer.prototype.$getInternalModel = function () {
  return this._internalModel;
};

Layer.prototype._reloadEngine = function () {
  if (this._engine) {
    return this._engine.reload();
  }

  return Promise.resolve();
};

Layer.$nextId = 0;
Layer.$generateId = function () {
  return 'L' + ++Layer.$nextId;
};

function getInteractivityFields (columns) {
  var fields = columns.map(function (column, index) {
    return {
      name: column,
      title: true,
      position: index
    };
  });

  return {
    fields: fields
  };
}

/**
 * @typedef {Object} LatLng
 * @property {number} lat - Latitude
 * @property {number} lng - Longitude
 * 
 * @api
 */

module.exports = Layer;
